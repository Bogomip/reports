{"ast":null,"code":"import { of } from 'rxjs';\nimport { map, take, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../services/database.service\";\nimport * as i2 from \"./sentences.service\";\nimport * as i3 from \"./tests.service\";\nimport * as i4 from \"src/app/services/groups.service\";\nimport * as i5 from \"./templates.service\";\nimport * as i6 from \"../utilities/authentication/authentication.service\";\nexport let ReportsService = /*#__PURE__*/(() => {\n  class ReportsService {\n    constructor(db, sentenceService, testsService, groupsService, templateService, auth) {\n      this.db = db;\n      this.sentenceService = sentenceService;\n      this.testsService = testsService;\n      this.groupsService = groupsService;\n      this.templateService = templateService;\n      this.auth = auth;\n      this.reports = [];\n    }\n    /**\r\n     * Retrieves all user reports from the database...\r\n     * todo: add local storage;\r\n     * @returns\r\n     */\n\n\n    getReports(forcedFromDatabase = false) {\n      this.reports = []; // if the data exists locally, grab it!\n\n      if (localStorage.getItem('reports-data') !== null && forcedFromDatabase === false) {\n        // retrieve the data from local storage and parse it into the templates data...\n        this.reports = JSON.parse(localStorage.getItem('reports-data')); // set the data on the display\n        // and return the data array...\n\n        return of(this.reports).pipe(take(1), tap(returnData => {\n          return returnData;\n        }));\n      } else {\n        // get from the DB\n        return this.db.getReports().pipe(take(1), map(queryResults => {\n          let reportsNew = []; // build the rpeorts...\n\n          queryResults.forEach(report => {\n            let newReport = this.convertBackToArrays(report.data()); // add the id...\n\n            newReport.id = report.id; // rebuild the arrays :(\n\n            let rebuilt = this.convertBackToArrays(newReport); // and push tot he main array\n            // reportsNew.push(newReport);\n\n            reportsNew.push(rebuilt);\n          }); // set the variable\n\n          this.reports = reportsNew; // set the local sotrage\n\n          this.setlocalStorage(this.reports);\n          return reportsNew;\n        }, error => {\n          console.log(`Error: ${error}`);\n        }));\n      }\n    }\n    /**\r\n     * stores the data in the local storage\r\n     *\r\n     * @param reports\r\n     */\n\n\n    setlocalStorage(reports) {\n      localStorage.setItem('reports-data', JSON.stringify(reports));\n    }\n    /**\r\n     * Gets an individual report.\r\n     * @param id\r\n     * @returns\r\n     */\n\n\n    getReport(id) {\n      if (this.reports.length === 0) {\n        // load the reports into the menu\n        return this.getReports().pipe(take(1), map(data => {\n          this.reports = data; // return the correct report.\n\n          return this.returnReport(id);\n        }, error => {\n          console.log(`Error: ${error}`);\n        }));\n      } else {\n        return of(this.returnReport(id));\n      }\n    }\n    /**\r\n     * Returns a single report from the database...\r\n     * @param id\r\n     * @returns\r\n     */\n\n\n    returnReport(id) {\n      let reportIndex = this.reports.findIndex(repo => repo.id === id); // and return\n\n      if (reportIndex !== -1) {\n        return this.reports[reportIndex];\n      }\n    }\n\n    generateVariables(template) {\n      let globals = [];\n      let genderVariable = {\n        identifier: \"Gender\",\n        key: \"\",\n        value: \"\",\n        options: [\"f\", \"m\", \"p\"]\n      };\n      let variables = [genderVariable];\n      let splitRegex = new RegExp('\\\\$\\\\{(.*?)\\\\}\\\\$', 'g');\n      let duplicates = []; // look through the template for any globals that might be needed...\n\n      template.template.forEach(section => {\n        // this.sentenceService.generateSentenceOptions(section).forEach((option: {sentence: string, depth: number, delete: boolean}) => {\n        this.sentenceService.newTestSentenceOptionCreator(template.template).forEach(option => {\n          let typeMatches; // get the values form the sentence that are between ${brackets}$ and put them in values\n\n          while (typeMatches = splitRegex.exec(option)) {\n            let exists = duplicates.findIndex(temp => temp === typeMatches[1]); // test if its already been identified and if not, push onto the array\n\n            if (exists === -1) {\n              // duplicates array used to ensure no doubles...\n              duplicates.push(typeMatches[1]);\n              console.log(typeMatches[1]); // find if its a global or variable\n\n              let data = typeMatches[1].split('|'); // get any options options (surrounded by [ ] separated by ,)\n\n              let optionsRegex = new RegExp('\\\\[(.*?)\\\\]', 'g');\n              let optionsMatches;\n              let options = []; // let optionObject = {};\n              // and get the options, if any...\n\n              while (optionsMatches = optionsRegex.exec(data[1])) {\n                options = optionsMatches[1].split(',');\n              } // finally build the variable to put into the reports array\n\n\n              let newVariable;\n              let identifier = data[1].split('[')[0];\n\n              switch (data[0]) {\n                case 'g':\n                  // this is a global values\n                  newVariable = {\n                    identifier: identifier,\n                    value: \"\",\n                    options: options\n                  };\n                  globals.push(newVariable);\n                  break;\n\n                case 'v':\n                  // this is a variable value (assume no |, or should I add v|??)\n                  newVariable = {\n                    identifier: identifier,\n                    key: \"\",\n                    value: \"\",\n                    options: options\n                  };\n                  variables.push(newVariable);\n                  break;\n              }\n            }\n          }\n        });\n      }); // return both arrays...\n\n      return [globals, variables];\n    }\n\n    generateTests(template) {\n      let testVals = [];\n      template.template.forEach(template => {\n        // get the sentence data\n        let testData = this.sentenceService.getCompoundSentenceData(template, true, ['tests']); // loops over all options (need data for it all!)\n\n        testData.forEach(individualOption => {\n          // and iterate\n          individualOption.forEach(temp => {\n            // iterate over the results... again!!               \n            temp.forEach(templateInfo => {\n              // if tests exist...\n              if (templateInfo.tests) {\n                templateInfo.tests.forEach(test => {\n                  // check if this test is already added\n                  const testIndex = testVals.findIndex(t => test.identifier === t.identifier); // if not there, add it...\n\n                  if (testIndex === -1) {\n                    // get the test we are intersted in...\n                    let newTest = this.testsService.getTest(test.identifier);\n                    let testValues = {\n                      name: test.name,\n                      identifier: test.identifier,\n                      values: []\n                    }; // if default settings are required then set those up here...\n\n                    if (\"settings\" in newTest) {\n                      let settings = {\n                        name: newTest.settings.name,\n                        value: {\n                          name: \"\",\n                          options: {}\n                        },\n                        options: newTest.settings.options\n                      }; // default options apply...\n\n                      testValues.settings = settings;\n                    }\n\n                    let testOptions;\n\n                    if (newTest.settings.options.length === 1) {\n                      testOptions = Object.values(newTest.settings.options[0].options);\n                    } else {\n                      testOptions = newTest.test.options;\n                    } // make an array to return...\n                    // iterate over the variables imn the test...\n\n\n                    newTest.variables.forEach(test => {\n                      // add the new test to the testvalues array...\n                      testValues.values.push({\n                        identifier: test.identifier,\n                        name: test.name,\n                        key: \"\",\n                        value: \"\",\n                        options: testOptions ? testOptions : []\n                      });\n                    });\n                    testVals.push(testValues);\n                  } // else already added\n\n                });\n              }\n            });\n          });\n        });\n      }); // and return lol :(\n\n      return testVals;\n    } // database functions\n\n    /**\r\n     * Updates the report object in the database...\r\n     * @param report\r\n     * @param reportId\r\n     * @returns\r\n     */\n\n\n    updateReport(report, reportId) {\n      // first convert the variables into maps so firebase supports the data type...\n      // ALL TYPE HERE IS NULL, SINGLE FUNCTIONS\n      // DO NOT USE OUTSIDE OF THIS...\n      let reportCopyForFirebase = JSON.parse(JSON.stringify(report));\n      let newTests = this.convertTestValuesToObjectArray(reportCopyForFirebase.tests);\n      let newGlobals = this.convertGlobalValuesToObjectArray(reportCopyForFirebase.globals);\n      let newVariables = this.convertVariableValuesToObjectArray(reportCopyForFirebase.variables); // let newReports = this.convertTemplateRouteToObjectArray(reportCopyForFirebase.reports);\n\n      reportCopyForFirebase.globals = newGlobals;\n      reportCopyForFirebase.variables = newVariables;\n      reportCopyForFirebase.tests = newTests; // reportCopyForFirebase.reports = newReports;\n      // call the database function and return true if it succeeds and false if it fails...\n\n      return this.db.updateReport(reportCopyForFirebase, reportId).pipe(take(1), tap(() => {\n        // success\n        // update the reports structure...\n        let reportsContainerId = this.reports.findIndex(temp => temp.id === reportId); // and set the data based upon the result and then update local storage....\n\n        if (reportsContainerId === -1) {\n          // this report isnt on the reports object for some reason, add it...\n          this.reports.push(report);\n        } else {\n          // found it, modify...\n          this.reports[reportsContainerId] = report;\n        }\n\n        this.setlocalStorage(this.reports);\n        return true;\n      }, error => {\n        console.log(`Error: ${error}`);\n        return false;\n      }));\n    }\n    /**\r\n     * Deletes a report from the database...\r\n     * @param id\r\n     * @returns\r\n     */\n\n\n    deleteReport(id) {\n      return this.db.deleteReport(id).pipe(take(1), tap(() => {\n        // remove from the local storage also..\n        let repoIndex = this.reports.findIndex(temp => temp.id === id);\n\n        if (repoIndex !== -1) {\n          // delete from the db, doesnt inform the caller of the error though and it will stay in local database.\n          this.reports.splice(repoIndex, 1);\n          this.setlocalStorage(this.reports);\n        }\n\n        return true;\n      }, error => {\n        console.log(`Error: ${error}`);\n        return false;\n      }));\n    }\n    /**\r\n     * Create a new report object in the database, get the id...\r\n     * @param report\r\n     * @returns\r\n     */\n\n\n    createReport(report) {\n      // first convert the variables into maps so firebase supports the data type...\n      // ALL TYPE HERE IS NULL, SINGLE FUNCTIONS\n      // DO NOT USE OUTSIDE OF THIS...\n      let reportCopyForFirebase = JSON.parse(JSON.stringify(report));\n      let newTests = this.convertTestValuesToObjectArray(reportCopyForFirebase.tests);\n      let newGlobals = this.convertGlobalValuesToObjectArray(reportCopyForFirebase.globals);\n      let newVariables = this.convertVariableValuesToObjectArray(reportCopyForFirebase.variables); // let newReports = this.convertTemplateRouteToObjectArray(reportCopyForFirebase.reports);\n\n      reportCopyForFirebase.globals = newGlobals;\n      reportCopyForFirebase.variables = newVariables;\n      reportCopyForFirebase.tests = newTests; // reportCopyForFirebase.reports = newReports;\n      // return the observable///\n\n      return this.db.addNewReport(reportCopyForFirebase).pipe(take(1), tap(res => {\n        // success\n        report.id = res.id; // add to the other reports.. and update local storage...\n\n        this.reports.push(report);\n        this.setlocalStorage(this.reports);\n      }, error => {\n        console.log(`Error: ${error}`);\n        return false;\n      }));\n    } // firebase multidimenional support fucntions :(\n\n    /**\r\n     * Ridiculous multidimensional support sheninigans...\r\n     * @param report\r\n     * @returns\r\n     */\n\n\n    convertBackToArrays(report) {\n      // do the template arrays first...    \n      // let templateArray = Object.values(report.reports[0].template.template);\n      // let newTemplateArray: [string[]] = [[]];\n      // // and sub routes...\n      // templateArray.forEach((route: {}, i: number) => {\n      //     let newRoute: string[] = Object.values(route);\n      //     if(i === 0) {\n      //         newTemplateArray[0] = newRoute;\n      //     } else {\n      //         newTemplateArray.push(newRoute);\n      //     }\n      // })\n      // // place back onto the users...\n      // report.reports.forEach((temp: Report) => {\n      //     temp.template.template = newTemplateArray;\n      // });\n      // VARIABLES....\n      let newVariables = Object.values(report.variables);\n      newVariables.forEach((usrVariable, i) => {\n        let varOptions = Object.values(usrVariable.options);\n        newVariables[i].options = varOptions;\n      }); // Globals....\n\n      let newGlobals = Object.values(report.globals);\n      newGlobals.forEach((usrGlobal, i) => {\n        let varOptions = Object.values(usrGlobal.options);\n        newGlobals[i].options = varOptions;\n      }); // now do the tests...\n\n      let testsObject = Object.values(report.tests);\n      testsObject.forEach((test, i) => {\n        let valuesArray = Object.values(test.values);\n        valuesArray.forEach((individual, s) => {\n          let optionsArray = Object.values(individual.options); // valuesArray[s].values[s].options = optionsArray;\n\n          valuesArray[s].options = optionsArray;\n        });\n        test.values = valuesArray;\n      }); // rebuild the report...        \n\n      let newReport = {\n        name: report.name,\n        groupId: report.groupId,\n        templateId: report.templateId,\n        id: report.id,\n        manager: report.manager,\n        variables: newVariables,\n        globals: newGlobals,\n        tests: testsObject,\n        keys: report.keys,\n        reports: report.reports,\n        lastUpdated: report.lastUpdated\n      };\n      return newReport;\n    }\n    /**\r\n     * The point of this is to convert the entirety of the tests array into an object\r\n     *\r\n     * This is aid its storage on firebase which does not support multidimensional arrays.\r\n     *\r\n     * @param tests\r\n     * @returns\r\n     */\n\n\n    convertTestValuesToObjectArray(tests) {\n      let returnObject = {}; // iterate over all of the tests\n      // use of the any object here liberally used to reduce type errors haxxily and to prevent the need\n      // for a bunch of other objects/interfaces which will not use used outside of this function.\n\n      tests.forEach((test, i) => {\n        let valuesObject = {}; // iterate over all of the tests...\n\n        test.values.forEach((testValue, s) => {\n          let testOptions = {};\n          testValue.options.forEach((opt, t) => {\n            testOptions[t] = opt;\n          });\n          testValue.options = testOptions;\n          valuesObject[s] = testValue;\n        });\n        test.values = valuesObject;\n        returnObject[i] = test;\n      });\n      return returnObject;\n    }\n\n    convertGlobalValuesToObjectArray(globals) {\n      let returnObject = {};\n      globals.forEach((global, i) => {\n        let globalOptions = {};\n        global.options.forEach((globalValue, s) => {\n          globalOptions[s] = globalValue;\n        });\n        global.options = globalOptions;\n        returnObject[i] = global;\n      });\n      return returnObject;\n    }\n\n    convertVariableValuesToObjectArray(variables) {\n      let returnObject = {};\n      variables.forEach((variables, i) => {\n        let variablesOptions = {};\n        variables.options.forEach((variablesValue, s) => {\n          variablesOptions[s] = variablesValue;\n        });\n        variables.options = variablesOptions;\n        returnObject[i] = variables;\n      });\n      return returnObject;\n    } // convertTemplateRouteToObjectArray(report: Report[]): any {\n    //     let returnObject: any[] = [...report];\n    //     // get a single template, assume its the same for everyone at this point\n    //     let singleTemplate: any = report[0].template.template;\n    //     let singleReturn: {} = {};\n    //     singleTemplate.forEach((temp: any, i: number) => {\n    //         let route: {} = {};\n    //         temp.forEach((option: string, s: number) => {\n    //             route[s] = option;\n    //         })\n    //         temp = route;\n    //         singleReturn[i] = temp;\n    //     })\n    //     // then place this back onto the reports...\n    //     returnObject.forEach((rep: any) => {\n    //         rep.template.template = singleReturn;\n    //     })\n    //     return returnObject;\n    // }\n\n    /**\r\n     * REPORT GENERATION\r\n     */\n\n\n    testExecutability(reportdocument) {\n      let execute = {\n        global: true,\n        variables: true,\n        tests: true\n      }; // check global values have been set\n\n      reportdocument.globals.every(global => {\n        execute.global = global.value === \"\" ? false : true;\n        return execute.global === true ? true : false;\n      }); // check variables have a key assigned to them\n\n      reportdocument.variables.every(variable => {\n        execute.variables = variable.key === \"\" ? false : true;\n        return execute.variables === true ? true : false;\n      });\n      reportdocument.tests.forEach(test => {\n        // each variable one ach TEST needs a key\n        test.values.every(test => {\n          execute.tests = test.key === \"\" ? false : true;\n          return execute.tests === true ? true : false;\n        });\n      }); // if any are false this will return false;\n\n      return execute.global && execute.variables && execute.tests;\n    }\n    /**\r\n     * Takes a report documnet and converts all reports into readable progress reports.\r\n     * @param reportDocument\r\n     * @returns\r\n     */\n\n\n    generateBatchReports(reportDocument) {\n      // this is where the magic happens :-)\n      let globalVariables = reportDocument.globals;\n      let variableVariables = reportDocument.variables;\n      let testVariables = reportDocument.tests; // ITERATE Over all reports...\n\n      reportDocument.reports.forEach(individualReport => {\n        // generate a report for this user...\n        individualReport.report = this.generateIndividualReports(individualReport, globalVariables, variableVariables, testVariables);\n      }); // return the original modified reportdocument.\n\n      return reportDocument;\n    }\n    /**\r\n     * Takes a single report interface object and uses data from the template to generate a report...\r\n     * gender defaults to they/them/their if no gender is submitted.\r\n     * @param report\r\n     * @param reportDocument\r\n     * @returns\r\n     */\n\n\n    generateIndividualReports(report, globals, variables, tests) {\n      // get the gender if it exists...\n      let genderIndex = variables.findIndex(test => test.identifier === \"Gender\");\n      let gender = \"p\"; // if it exists then reassign else leave it as p (plural!)\n\n      if (genderIndex !== -1) {\n        gender = report.user.data[variables[genderIndex].key];\n      } // first we need a sentence structure generated for this template.\n\n\n      let template = this.templateService.getTemplate(report.templateId);\n      let minCharacters = template.characters.min;\n      let maxCharacters = template.characters.max;\n      let sentenceOptionsTested = this.sentenceService.newTestSentenceOptionCreator(template.template, report.user, tests); // if we have any results...\n\n      if (sentenceOptionsTested.length > 0) {\n        // trim down to the sentences which match the character range...\n        sentenceOptionsTested.filter(sentence => sentence.length >= minCharacters && sentence.length <= maxCharacters); // select a random value to pick at random a sentence from the options avaikable\n\n        let randomValueForSelect = Math.floor(Math.random() * sentenceOptionsTested.length);\n        let reportUnSubstituted = sentenceOptionsTested[randomValueForSelect]; // now sub in values    \n\n        globals.forEach(global => {\n          reportUnSubstituted = this.valuesSubstitute(reportUnSubstituted, 'g\\\\|' + global.identifier, global.value);\n        });\n        variables.forEach(variable => {\n          reportUnSubstituted = this.valuesSubstitute(reportUnSubstituted, 'v\\\\|' + variable.identifier, report.user.data[variable.key]);\n        });\n        reportUnSubstituted = this.substitutions(reportUnSubstituted, gender); // return selected sentence\n\n        return reportUnSubstituted;\n      } else {\n        return \"\";\n      }\n    }\n    /**\r\n     * Runs the grammar check functions.\r\n     * Sometimes this is not going to be super smart.\r\n     * @param report\r\n     * @returns\r\n     */\n\n\n    substitutions(report, gender) {\n      report = this.sentenceCase(report);\n      report = this.repeatCharacterRemoval2(report); // gender transform...\n\n      report = this.genderConversion(report, gender); // optional words - must come after grammar check as the style of writing i the same and pickaword will choos eat random\n\n      report = this.anOrA(report); // must come before pickaword as the syntax for selection is the same, and if pick came first it will select anora     \n\n      report = this.pickAWord(report); // this should be the last of the [] notations as it selects the worths within the brackets as opposed to an action based upon the content [AnOrA], PICK An or A depending on the next letter for example.\n      // finally remove the whitespace;\n\n      report = this.removeWhiteSpace(report);\n      return report;\n    }\n    /**\r\n     * Substitutes variables into the text...\r\n     * @param report\r\n     * @param substitution\r\n     * @param value\r\n     * @returns\r\n     */\n\n\n    valuesSubstitute(report, substitution, value) {\n      // first if there is a (notation) then escape it so it works properly...\n      substitution = substitution.replace(/[()]/g, '\\\\$&'); // then get to replacing text!\n\n      let strReplace = new RegExp('\\\\$\\\\{(' + substitution + ')+(\\\\[.*?])?\\\\}\\\\$', 'gi');\n      let regExData;\n\n      while ((regExData = strReplace.exec(report)) !== null) {\n        report = report.replace(regExData[0], value);\n        strReplace.lastIndex = 0;\n      }\n\n      return report;\n    }\n    /**\r\n     * Dea with gender values...\r\n     * @param report\r\n     * @param gender\r\n     * @returns\r\n     */\n\n\n    genderConversion(report, gender) {\n      let genderUnique = gender.toLowerCase();\n      let genderIndex = genderUnique === \"m\" ? 0 : genderUnique === \"f\" ? 1 : 2;\n      let strReplace = new RegExp('\\\\$\\\\{(gn\\\\|(.*?)/(.*?)/(.*?))+(\\\\[.*?])?\\\\}\\\\$', 'gi'); // wil;l this only work once??????? :S\n\n      let regexData;\n\n      while ((regexData = strReplace.exec(report)) !== null) {\n        report = report.replace(regexData[0], regexData[2 + genderIndex]);\n        strReplace.lastIndex = 0;\n      } // return\n\n\n      return report;\n    }\n    /**\r\n     * If multiple optionsal words exist in a bracket notation [this/that]\r\n     * then this function will randomly select one of the words.\r\n     * @param report\r\n     * @returns\r\n     */\n\n\n    pickAWord(report) {\n      let strReplace = new RegExp('\\\\[(.*?)\\\\]', 'gi');\n      let regExData;\n\n      while ((regExData = strReplace.exec(report)) !== null) {\n        // recursive options support - only one level deep allowed otherwise things get too complex\n        let options = regExData[1].split('/');\n        let randomValue = Math.floor(Math.random() * options.length);\n        report = report.replace(regExData[0], options[randomValue]);\n        strReplace.lastIndex = 0;\n      }\n\n      return report;\n    }\n    /**\r\n     * Is it an AN or an A.\r\n     * RULES: If the next word is a CONSONANT then its A, if its a VOWEL then its AN.\r\n     * 90% of the time this will be followed by a grade!\r\n     * @param report\r\n     * @returns\r\n     */\n\n\n    anOrA(report) {\n      let strReplace = new RegExp('\\\\[AnOrA\\\\]+(.*)?', 'gi');\n      let regExData;\n\n      while ((regExData = strReplace.exec(report)) !== null) {\n        let choice = regExData[1].trimStart()[0].toLowerCase() === (\"a\" || \"e\" || \"i\" || \"o\" || \"u\") || !isNaN(+regExData[1].trimStart()) ? \"an\" : \"a\";\n        let newStr = regExData[0].replace(\"[AnOrA]\", choice);\n        report = report.replace(regExData[0], newStr);\n        strReplace.lastIndex = 0;\n      }\n\n      return report;\n    }\n    /**\r\n     * Tidies up any sentence case issues.\r\n     * - Put a . at the end if there isnt one.\r\n     * - Put a space after a . and capitalise the first letter\r\n     * - Capitalise the first letter of the whoole thing.\r\n     *\r\n     * @param report\r\n     * @returns\r\n     */\n\n\n    sentenceCase(report) {\n      let uppered = report;\n      let result = \"\";\n      let sentences = uppered.split('.'); // each sentence should have a capital letter...\n\n      sentences.forEach((sentence, i) => {\n        i !== 0 ? result += \" \" : null;\n        result += (sentence.charAt(0).toUpperCase() + sentence.slice(1)).trimLeft() + '.';\n      }); // return\n\n      return result;\n    }\n    /**\r\n     * Removes whitespace at the start and end of the text\r\n     * strips any double whitespaces\r\n     * removes whitespace right before a , or a .\r\n     * @param report\r\n     * @returns\r\n     */\n\n\n    removeWhiteSpace(report) {\n      // get rid of multiple whitespaces...\n      report = report.trim().replace(/\\s\\s+/g, ''); // ensure there is also a whitespace after a fullstop or a comma...\n\n      let sentences = report.split('.'); // remove all whitespace within the sentences, at the start and end of the . and , structures...\n\n      sentences.forEach(sentence => {\n        // then split into commas...\n        let sections = sentence.split(',');\n        sections.forEach((section, i) => {\n          section.trim(); // if its the end of the sentence use a full stop, optherwise use a comma and space...\n        });\n      }); // recombined.replace(' +/gi', ' ');\n\n      return report;\n    }\n\n    repeatCharacterRemoval2(report) {\n      let regExComma = new RegExp('[ ,]{2,}', 'gi');\n      let regExFS = new RegExp(/(\\.[\\s]{1,}\\.)/gm);\n      let regExString;\n\n      while ((regExString = regExComma.exec(report)) !== null) {\n        report = report.replace(regExString[0], ', ');\n      }\n\n      while ((regExString = regExFS.exec(report)) !== null) {\n        report = report.replace(regExString[0], '.');\n      }\n\n      return report;\n    }\n\n    repeatCharacterRemoval(report) {\n      let chars = [',,', '..', ',.', '.,'];\n      chars.forEach(char => {\n        let regEx = new RegExp('[' + char + ']{2,10}', 'gi');\n        let regExString;\n\n        while ((regExString = regEx.exec(report)) !== null) {\n          report = report.replace(regExString[0], regExString[0].charAt(0));\n          regEx.lastIndex = 0;\n        }\n      });\n      return report;\n    }\n\n  }\n\n  ReportsService.ɵfac = function ReportsService_Factory(t) {\n    return new (t || ReportsService)(i0.ɵɵinject(i1.DatabaseService), i0.ɵɵinject(i2.SentencesService), i0.ɵɵinject(i3.TestsService), i0.ɵɵinject(i4.GroupsService), i0.ɵɵinject(i5.TemplatesService), i0.ɵɵinject(i6.AuthenticationService));\n  };\n\n  ReportsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ReportsService,\n    factory: ReportsService.ɵfac,\n    providedIn: 'root'\n  });\n  return ReportsService;\n})();","map":null,"metadata":{},"sourceType":"module"}