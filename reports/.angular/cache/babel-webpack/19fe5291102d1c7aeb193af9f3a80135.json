{"ast":null,"code":"import { of, Subject } from 'rxjs';\nimport { map, take, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../utilities/authentication/authentication.service\";\nimport * as i2 from \"./database.service\";\nexport let TemplatesService = /*#__PURE__*/(() => {\n  class TemplatesService {\n    constructor(auth, db) {\n      this.auth = auth;\n      this.db = db;\n      this.menuData = new Subject();\n      this.templates = []; // subscribe to the user details;\n\n      auth.user.subscribe(user => {\n        this.user = user;\n      });\n    }\n    /**\r\n     * Get the best version of the templates and return it\r\n     * (either from local storage or the database...)\r\n     * @returns\r\n     */\n\n\n    getTemplates(forcedFromDatabase = false) {\n      this.templates = []; // check local sotrage first...\n\n      if (localStorage.getItem('templates-data') !== null && forcedFromDatabase === false) {\n        // retrieve the data from local storage and parse it into the templates data...\n        this.templates = JSON.parse(localStorage.getItem('templates-data')); // set the data on the display\n\n        return of(this.templates).pipe(take(1), tap(returnData => {\n          // return the data array...\n          return returnData;\n        }));\n      } else {\n        // no local sotrage available so retrieve from databse...\n        return this.db.getTemplates().pipe(take(1), map(resultsArray => {\n          resultsArray.forEach(template => {\n            let temp = template.data();\n            let routes = [[]];\n            let id = template.id; // split the routes up(entered into db as 123456|abcdef etc)\n\n            temp.template.forEach(route => {\n              const routeIds = route.split(\"|\");\n              routes.push(routeIds);\n            }); // build the new template data to use in the app\n\n            let newTemplate = {\n              id: id,\n              name: temp.name,\n              public: temp.public,\n              characters: {\n                min: temp.characters.min,\n                max: temp.characters.max\n              },\n              template: routes\n            }; // and add to the templayte object\n\n            this.templates.push(newTemplate);\n          }); // set the data into local storage to make it quicker ot retrieve next time...\n\n          localStorage.setItem('templates-data', JSON.stringify(this.templates));\n          return this.templates;\n        }));\n      }\n    }\n    /**\r\n     * send a single template\r\n     * @param id\r\n     * @returns\r\n     */\n\n\n    getTemplate(id) {\n      let index = this.templates.findIndex(temp => temp.id === id);\n      return this.templates[index];\n    }\n    /**\r\n     * When data changes emit the new data to anything that cares.\r\n     * @param id\r\n     * @param name\r\n     * @param deleted\r\n     */\n\n\n    dataChange(data) {\n      this.menuData.next(data);\n    }\n    /**\r\n     * Adds a new template to the templates.\r\n     *\r\n     * @param newTemplate\r\n     */\n\n\n    addNewTemplate(newTemplate, rawRoutes) {\n      // generate a new templatedb for the database...\n      let tempDb = Object.assign(Object.assign({}, newTemplate), {\n        manager: this.user.id,\n        template: this.parseTemplate(rawRoutes)\n      }); // return the databse update object\n\n      return this.db.addTemplate(tempDb).pipe(take(1), tap(result => {\n        let temp = Object.assign(Object.assign({}, newTemplate), {\n          id: result.id,\n          template: rawRoutes\n        }); // add to the local array\n\n        this.templates.push(temp); // update local storage - always happens...\n\n        this.updateLocalStorage(this.templates);\n      }));\n    }\n    /**\r\n     * Updates a template of a specific id and then updates local storage...\r\n     * @param template\r\n     * @param id\r\n     * @returns\r\n     */\n\n\n    updateTemplate(template) {\n      // find the correct template using the id and update;\n      let templateIndex = this.templates.findIndex(temp => temp.id === template.id); // found it so update local storage...\n\n      if (templateIndex !== -1) {\n        this.templates[templateIndex] = template; // always update local storage...\n\n        this.updateLocalStorage(this.templates); // update the template database and return as an async thing ...\n\n        return this.updateDatabase(template, template.id).pipe(take(1));\n      }\n    }\n    /**\r\n     * deletes a template from the database...\r\n     * @param id\r\n     * @returns\r\n     */\n\n\n    deleteTemplate(id) {\n      return this.db.deleteTemplate(id).pipe(take(1), tap(() => {\n        // success, find and remove from array\n        let tempIndex = this.templates.findIndex(temp => temp.id === id);\n        this.templates.splice(tempIndex, 1); // update local storage\n\n        this.updateLocalStorage(this.templates); // return true to show its been deleted.\n\n        return true;\n      }, error => {\n        console.log(`Error: ${error}`);\n        return false;\n      }));\n    }\n    /**\r\n     * Updates the storage on the local machine - used to speed up the whole application\r\n     * but essentially mirrors the database.\r\n     * @param templates\r\n     */\n\n\n    updateLocalStorage(templates) {\n      localStorage.setItem('templates-data', JSON.stringify(templates));\n    }\n    /**\r\n     * Update the database with new information.\r\n     * @param template\r\n     * @param id\r\n     * @returns\r\n     */\n\n\n    updateDatabase(template, id) {\n      // generate a new databse template format. only if templatw type passes is Template...\n      let temp = {\n        name: template.name,\n        public: template.public,\n        characters: {\n          min: template.characters.min,\n          max: template.characters.max\n        },\n        template: this.parseTemplate(template.template),\n        manager: this.user.id\n      }; // and update the database.\n\n      return this.db.updateTemplate(temp, id).pipe(take(1), tap(result => {\n        // success...\n        return true;\n      }, error => {\n        console.log(`Error updating database: ${error}`);\n        return false;\n      }));\n    }\n    /**\r\n     * Takes a template from Template format (for use on the site) to TemplateDB format (for storage)\r\n     * @param routes\r\n     * @returns\r\n     */\n\n\n    parseTemplate(routes) {\n      // parse the template first\n      let parsedTemplate = []; // iterate and put it in databaseformat.\n\n      routes.forEach(template => {\n        let newTemplate = \"\"; // concatenate the routes...\n\n        template.forEach((temp, i) => {\n          if (i !== 0) {\n            newTemplate += \"|\";\n          }\n\n          newTemplate += temp;\n        });\n        parsedTemplate.push(newTemplate);\n      });\n      return parsedTemplate;\n    }\n\n  }\n\n  TemplatesService.ɵfac = function TemplatesService_Factory(t) {\n    return new (t || TemplatesService)(i0.ɵɵinject(i1.AuthenticationService), i0.ɵɵinject(i2.DatabaseService));\n  };\n\n  TemplatesService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: TemplatesService,\n    factory: TemplatesService.ɵfac,\n    providedIn: 'root'\n  });\n  return TemplatesService;\n})();","map":null,"metadata":{},"sourceType":"module"}