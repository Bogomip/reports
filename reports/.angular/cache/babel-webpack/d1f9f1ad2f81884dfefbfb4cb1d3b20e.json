{"ast":null,"code":"import { of } from 'rxjs';\nimport { map, take, tap } from 'rxjs/operators';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"../services/database.service\";\nimport * as i2 from \"./tests.service\";\nimport * as i3 from \"src/app/services/groups.service\"; // export interface sentenceString {\n//     text: string; tests?: {testname: string; value: number | string}[]\n// }\n// export interface sentence {\n//     id: string;\n//     endpoint?: boolean, starter?: boolean, \n//     name?: string, sentence?: string[], meta?: string | number\n//     subcategories?: [sentence], tests?: {name: string}[], \n//     index?: number; order?: number\n// }\n\nexport let SentencesService = /*#__PURE__*/(() => {\n  class SentencesService {\n    constructor(databaseService, testsService, groupService) {\n      this.databaseService = databaseService;\n      this.testsService = testsService;\n      this.groupService = groupService; // these do NOT need to be an array, but in a slow start everything got coded this way and so thats how it is!...\n\n      this.sentenceData = []; // test1: [number[]] = [[4, 5, 4, 5]];\n      // test2: number[][] = [[4, 5],[4, 5]];\n\n      this.route = ['id1/id2', 'id3/id4', 'id5/id6'];\n      this.routePreSplit = [['id1', 'id2'], ['id3', 'id4'], ['id5', 'id6']]; // dont this way to make sure I am happy with the map function which I havent used before!\n\n      this.output = this.cartesianProduct(this.routePreSplit);\n    }\n    /**\r\n     * Gets the sentence data from memory or from the database and returns it as an observable...\r\n     * @returns\r\n     */\n\n\n    getSentencesDatabase(uid, forcedFromDatabase = false) {\n      // check if there is an instance of the sentences database in localstorage...\n      if (localStorage.getItem('sentences-data') !== null && forcedFromDatabase === false) {\n        // retrieve the data from local storage and parse it into the sentence data...\n        this.sentenceData = JSON.parse(localStorage.getItem('sentences-data')); // set the data on the display\n\n        return of(this.sentenceData[0]).pipe(take(1), tap(returnData => {\n          // return the data array...\n          return returnData;\n        }));\n      } else {\n        // no instance of the saved data so get a fresh version.\n        const docId = uid ? uid : 'template';\n        return this.databaseService.getSentences(docId).pipe(take(1), map(returnData => {\n          // add data to the sentenceData array...\n          // (this is an array as originally multiple database could be retrieved but then only one...)\n          this.sentenceData[0] = returnData.data(); // set the data into local storage to make it quicker ot retrieve next time...\n\n          localStorage.setItem('sentences-data', JSON.stringify(this.sentenceData)); // and return\n\n          return this.sentenceData[0];\n        }, error => {\n          console.log(`Error retrieving data: ${error.message}`);\n        }));\n      }\n    }\n    /**\r\n     *\r\n     * @returns Returns the current state of the database.\r\n     */\n\n\n    getCurrentSentenceData() {\n      return this.sentenceData;\n    }\n\n    replaceWithTemplate(uid) {\n      // get tht template to write...\n      const replace = this.databaseService.getSentences('template').pipe(take(1), tap(templateResults => {\n        // and rewrite..\n        // const rewrite = this.databaseService.uploadSentences(uid, templateResults.data()).pipe(take(1), tap(() => {\n        //     // nothing to do here...\n        // }, error => {\n        //     console.log(`Error rewriting template: ${error.message}`)\n        // }));\n        // Dont auto rewrite to the database, but let the user have the opportunity to make that save...\n        this.sentenceData[0] = templateResults.data(); // set the data into local storage to make it quicker ot retrieve next time...\n\n        localStorage.setItem('sentences-data', JSON.stringify(this.sentenceData));\n        return this.sentenceData[0];\n      }, error => {\n        console.log(`Error rewriting template: ${error.message}`);\n      }));\n      return replace;\n    }\n    /**\r\n    * Get the data for the route selected.\r\n    *\r\n     * @param route the array of subcategories through the sentenceData array\r\n     * @param singleStream  whether or not to go down the route only or butterfly out\r\n     * @param data a list of key values to return (i.e. name, sentence etc)\r\n     */\n\n\n    getSentenceData(route, singleStream, data, infinite) {\n      // route must always start with a 0\n      route[0] = this.sentenceData[0].id; // id must always be included for id purposed...\n\n      data.indexOf(\"id\") === -1 ? data.push(\"id\") : \"\";\n      let ret = [[]]; // the any is a hax for now :/\n\n      let sntncData = this.sentenceData; // iterate over the route...\n\n      route.forEach((value, routePosition) => {\n        let subData;\n        let newReturnData = [{}];\n\n        for (let i = 0; i < sntncData.length; i++) {\n          if (sntncData[i].id === value) {\n            // this is the route we need...\n            // check to see if any subroutes exist, and if not create one..\n            if (Array.isArray(sntncData[i].subcategories)) {\n              subData = sntncData[i].subcategories;\n            } else {\n              // these two commented out lines were all that was here before infinite\n              // use if this breaks the function.\n              // sntncData[i].subcategories = [{name: \"New\", id: this.generateId()}];\n              // subData = sntncData[i].subcategories;\n              if (infinite || infinite === undefined) {\n                sntncData[i].subcategories = [{\n                  name: \"New\",\n                  id: this.generateId()\n                }];\n                subData = sntncData[i].subcategories;\n              } else {\n                // add subctegories...\n                break;\n              }\n            } // check to see if there is subdata, and if not just use the sentence stem\n\n\n            subData.forEach((dataStem, index) => {\n              // if a single stream is needed only select the appropriate routes...\n              if (!singleStream || route[routePosition + 1] === dataStem.id || routePosition + 1 === route.length) {\n                data.forEach(key => {\n                  // get the value for the key value pair\n                  const val = dataStem[key] ? dataStem[key] : undefined; // if it exists add it to the array\n\n                  if (val !== undefined) {\n                    const add = {\n                      [key]: val\n                    };\n                    newReturnData[index] = Object.assign(Object.assign({}, newReturnData[index]), add);\n                  }\n                });\n                const editParameters = {\n                  order: routePosition,\n                  index: index\n                };\n                newReturnData[index] = Object.assign(Object.assign({}, newReturnData[index]), editParameters);\n              }\n            }); // add the data to the return variable with no empty objects\n\n            ret[routePosition] = newReturnData.filter(stem => Object.keys(stem).length !== 0); // set the data stream as the subcategories of the first branch...\n\n            sntncData = sntncData[i].subcategories;\n          }\n        }\n      });\n      return ret;\n    }\n    /**\r\n     * Updated form of getsentencedata which takes multiple options into account...\r\n     * @param route\r\n     * @param singleStream\r\n     * @param data\r\n     * @returns\r\n     */\n\n\n    getCompoundSentenceData(route, singleStream = true, data = ['id']) {\n      let returnSentences = [];\n      let routeOptions = this.cartesianProduct(route.map(x => x.split('/'))); // foreach route found in the caresian product, ierate looking for the specified data.\n\n      routeOptions.forEach(sentenceOption => {\n        let newOption = this.getSentenceData(sentenceOption, singleStream, data);\n        returnSentences.push(newOption);\n      }); // return and will need to iterate over the results...\n\n      return returnSentences;\n    }\n    /**\r\n     * Get the names on the path for the given routes\r\n     * @param route\r\n     * @returns string of names\r\n     */\n\n\n    getRouteNames(route) {\n      let routeNames = [];\n      let depth = 0;\n      this.sentenceData.forEach(function iterate(routeId, index) {\n        if (route[depth] === routeId.id) {\n          routeNames[depth] = routeId.name; // recursively iterate through the sentence data\n\n          if (index < route.length && Array.isArray(routeId.subcategories)) {\n            depth++;\n            routeId.subcategories.forEach(iterate);\n          }\n        }\n      });\n      return routeNames;\n    }\n    /**\r\n     * Generates all potential options for sentences that could be make from a route\r\n     * @param route\r\n     */\n\n\n    generateSentenceOptions(route) {\n      const data = this.getSentenceData(route, true, ['name', 'sentence', 'starter', 'tests']);\n      let sentences = [{\n        sentence: \"\",\n        depth: 0,\n        delete: true\n      }]; // iterate over each level of the sentence builder...\n\n      data.forEach((stem, depth) => {\n        // iterate overall options within a level\n        const oldSentences = [...sentences];\n        stem.forEach(newStem => {\n          if (newStem.sentence) {\n            newStem.sentence.forEach(sentenceStem => {\n              // if (options) {\n              // options.forEach((sentenceStem: string) => {\n              const sentence = sentenceStem;\n              const starter = newStem.starter ? newStem.starter : false;\n\n              if (sentence) {\n                oldSentences.forEach((previousSentence, idx) => {\n                  let newSentence = previousSentence.sentence + sentence; // only if the new sentence is deeper than the old sentence can it be added.\n                  // peers do not add (sentences with the same depth)\n\n                  if (previousSentence.depth < depth + 1) {\n                    if (starter) {\n                      // if this is a starting sentence it should both add to previous elements\n                      // and have its own element.\n                      // ADD TO PREVIOUS SENTENCE\n                      sentences.push({\n                        sentence: newSentence,\n                        depth: depth,\n                        delete: false\n                      });\n                      sentences[idx].delete = true; // ADD NEW ELEMENT WITH THIS AS THE STARTER\n\n                      sentences.push({\n                        sentence: sentence,\n                        depth: depth,\n                        delete: false\n                      });\n                    } else {\n                      // if this is NOT a starting element it should add to previous elements\n                      // but NOT be added as its own element. Previous elements cannot happen without this\n                      // so the previous element should be flagged for deletion.\n                      // ADD TO PREVIOUS SENTENCE\n                      sentences.push({\n                        sentence: newSentence,\n                        depth: depth,\n                        delete: false\n                      }); // DELETE THE PREVIOUS SENTENCE\n\n                      sentences[idx].delete = true;\n                    }\n                  }\n                });\n              }\n            });\n          }\n        }); // after the first iteration remove the blank first entry\n\n        if (depth === 0) {\n          sentences.splice(0, 1);\n        } // iterate over the sentences and delete all that need to be deleted.\n\n\n        for (let i = sentences.length - 1; i >= 0; i--) {\n          if (sentences[i].delete === true) {\n            sentences.splice(i, 1);\n          }\n        }\n\n        return sentences;\n      }); // for some reason there are repeat sentences, delete them simply for now...\n\n      let unfiltered = [{\n        sentence: \"\",\n        depth: 0,\n        delete: true\n      }];\n      unfiltered.shift(); // this is so hax :/\n\n      sentences.forEach(a => {\n        let i = unfiltered.findIndex(b => a.sentence === b.sentence);\n        i === -1 ? unfiltered.push(a) : null;\n      }); // sort by length\n\n      unfiltered.sort((a, b) => {\n        return a.sentence.length - b.sentence.length;\n      });\n      return unfiltered;\n    }\n\n    generateTestedSentenceOptions(route, userData, tests) {\n      let report = [\"\"];\n      route.forEach((route, i) => {\n        // check if its a new paragraph...\n        if (route[0] === \"newParagraph\") {\n          report.map(temp => temp += \"</p><p>\");\n        } else {\n          // starting paragraph tag\n          if (i === 0) {\n            report.map(temp => temp += \"<p>\");\n          } // generate sentence option 1\n\n\n          const str = this.generateTestedSentence(route, userData, tests);\n          report.map(temp => {\n            temp += str;\n          }); // add all sentences to the final report array\n\n          str.forEach(temp => {\n            report.push(temp);\n          }); // close paragraph tag\n\n          if (i === route.length - 1) {\n            report.map(temp => temp += \"</p>\");\n          }\n        }\n      });\n      return report;\n    }\n\n    generateTestedSentence(route, userData, tests) {\n      let options = [];\n      const data = this.getSentenceData(route, true, ['name', 'sentence', 'starter', 'tests']);\n      let sentences = [{\n        sentence: \"\",\n        depth: 0,\n        delete: true\n      }]; // iterate over each level of the sentence builder...\n\n      data.forEach((stem, depth) => {\n        // iterate overall options within a level\n        const oldSentences = [...sentences];\n        stem.forEach(newStem => {\n          if (newStem.sentence) {\n            newStem.sentence.forEach(sentenceStem => {\n              const sentence = sentenceStem;\n              const starter = newStem.starter ? newStem.starter : false;\n\n              if (sentence) {\n                oldSentences.forEach((previousSentence, idx) => {\n                  let newSentence = previousSentence.sentence + sentence; // only if the new sentence is deeper than the old sentence can it be added.\n                  // peers do not add (sentences with the same depth)\n\n                  if (previousSentence.depth < depth + 1) {\n                    if (starter) {\n                      // if this is a starting sentence it should both add to previous elements\n                      // and have its own element.\n                      // ADD TO PREVIOUS SENTENCE\n                      sentences.push({\n                        sentence: newSentence,\n                        depth: depth,\n                        delete: false\n                      });\n                      sentences[idx].delete = true; // ADD NEW ELEMENT WITH THIS AS THE STARTER\n\n                      sentences.push({\n                        sentence: sentence,\n                        depth: depth,\n                        delete: false\n                      });\n                    } else {\n                      // if this is NOT a starting element it should add to previous elements\n                      // but NOT be added as its own element. Previous elements cannot happen without this\n                      // so the previous element should be flagged for deletion.\n                      // ADD TO PREVIOUS SENTENCE\n                      sentences.push({\n                        sentence: newSentence,\n                        depth: depth,\n                        delete: false\n                      }); // DELETE THE PREVIOUS SENTENCE\n\n                      sentences[idx].delete = true;\n                    }\n                  }\n                });\n              }\n            });\n          }\n        }); // after the first iteration remove the blank first entry\n\n        if (depth === 0) {\n          sentences.splice(0, 1);\n        } // iterate over the sentences and delete all that need to be deleted.\n\n\n        for (let i = sentences.length - 1; i >= 0; i--) {\n          if (sentences[i].delete === true) {\n            sentences.splice(i, 1);\n          }\n        }\n\n        return sentences;\n      }); // for some reason there are repeat sentences, delete them simply for now...\n\n      let unfiltered = [{\n        sentence: \"\",\n        depth: 0,\n        delete: true\n      }];\n      unfiltered.shift(); // this is so hax :/\n\n      sentences.forEach(a => {\n        let i = unfiltered.findIndex(b => a.sentence === b.sentence);\n        i === -1 ? unfiltered.push(a) : null;\n      });\n      unfiltered.forEach(opt => {\n        options.push(opt.sentence);\n      });\n      return options;\n    }\n\n    newTestSentenceOptionCreator(fullRoute, userData, tests) {\n      let finalOptions = []; // iterate over each part of the route...\n\n      fullRoute.forEach(route => {\n        let textArrays = [];\n        let data = this.sentenceData;\n        route.forEach(unSplitRoute => {\n          // split the route by / bars...\n          let splitRoutes = unSplitRoute.split('/');\n          let routeData = [];\n          splitRoutes.forEach(routeId => {\n            // THIS IS ALL CHECKING TESTS AGAINST USER DATA\n            // find out if this route is applicable to the user with any tests that might be happening.\n            let routeIndex = data.findIndex(temp => temp.id === routeId);\n            let testResults = [];\n            let allTrue = true; // check if there are any tests applicable on this data\n            // check first that the route still existts - if the template has changed the id may have disappeared.\n            // Poor system ready for renewal before its evenb launched :)\n\n            if (routeIndex !== -1 && tests) {\n              if (\"tests\" in data[routeIndex]) {\n                // check if the user passes the tests...\n                // console.log(data[routeIndex].tests);\n                let applicableTests = data[routeIndex].tests; // looop over all tests\n\n                applicableTests.forEach(testTemp => {\n                  // get the correct test from the test database...\n                  let test = this.testsService.getTest(testTemp.identifier);\n                  let newUserData = {\n                    id: userData.id,\n                    data: {}\n                  }; // get the data needed from the user...\n\n                  let testVariables = test.variables;\n                  testVariables.forEach(variable => {\n                    // find each variable identifvier in the userdata...\n                    // STUDENT OBJECT CHANGE TEST PHRASE\n                    variable.identifier in userData.data ? newUserData.data[variable.identifier] = userData.data[variable.identifier] : newUserData.data[variable.identifier] = \"\";\n                  }); // any settings may also needed and should be added to the array\n                  // NOT SURE THIS WILL WORK...\n\n                  let testIndex = tests.findIndex(tVal => tVal.identifier === testTemp.identifier);\n\n                  if (\"settings\" in test) {\n                    newUserData.data['settings'] = tests[testIndex].settings.value;\n                  } // submit the user data to the test to check if its truthy or falsey\n\n\n                  let testValue = test.calculateValueFunction(newUserData);\n                  let result = test.testFunction(testValue, testTemp.values.value); // push the result onto the array...\n\n                  testResults.push(result);\n                }); // this returns true if all tests are true. If any test is false, then eliminate this from the game!!\n\n                allTrue = !testResults.some(x => x === false);\n              }\n            } // END OF TESTS AGAINST USER DATA\n\n\n            if (allTrue) {\n              // iterate on the data\n              let sentenceValues = this.iterateSentenceFunction(data, routeId); // push to the main array\n\n              if (sentenceValues !== undefined) {\n                sentenceValues.length > 0 ? routeData.push(sentenceValues) : null;\n              }\n            }\n          }); // flatten this array so all options available to the user are on the same array...\n\n          textArrays.push(routeData.flat()); // ALL ID1/ID2/ID3 should be the last entry, it wouldnt make sense otherwise...\n          // find the index of the category just found and  make the data variables the subcategories...\n          // will return -1 for a split route as it wont find that unique id...\n\n          let subIndex = data.findIndex(temp => temp.id === unSplitRoute); // all of the previous data is on the same level so only increment data after they all have run.\n\n          if (subIndex !== -1) {\n            if (\"subcategories\" in data[subIndex]) {\n              data = data[subIndex].subcategories;\n            }\n          }\n        }); // weed out empty arrays\n\n        let newArray = textArrays.filter(temp => temp.length > 0 && /\\S/.test(temp[0])); // now to find all the sentence options by a cartesian transform on the data...\n\n        let returnArray = this.cartesianProduct(newArray); // and iterate over joining all the strings up for an array of options\n\n        let finalSentences = returnArray.map(str => str.join('')).map(str => str += '.');\n        finalOptions.push(finalSentences);\n      }); // weed out empty arrays\n\n      let newArray = finalOptions.filter(temp => temp.length > 0 && /\\S/.test(temp[0])); // now to find all the sentence options by a cartesian transform on the data...\n\n      let returnArray = this.cartesianProduct(newArray); // and iterate over joining all the strings up for an array of options\n\n      let finalSentences = returnArray.map(str => str.join('')); // and return all options :)\n\n      return finalSentences;\n    }\n    /**\r\n     * Simply extracts sentence strings from a sentence object based upon a route id\r\n     *\r\n     * @param data\r\n     * @param routeId\r\n     * @returns\r\n     */\n\n\n    iterateSentenceFunction(data, routeId) {\n      // get the relevant sentence\n      let sentenceIndex = data.findIndex(temp => temp.id === routeId); // get the sentence text array...\n\n      let sentences; // check the sentence exists...\n\n      if (sentenceIndex !== -1) {\n        // if there are sentences attached to this then push them to the return value\n        if (\"sentence\" in data[sentenceIndex]) {\n          // if there are sentences then return them.\n          sentences = data[sentenceIndex].sentence;\n        }\n      }\n\n      return sentences;\n    }\n    /**\r\n     * Generates an example sentence and gives the quantity of potential reports for this template\r\n     *\r\n     * Takes something of the form:\r\n     * [\r\n     *  [id1, id2, id3],\r\n     *  [newparagraph],\r\n     *  [id4,id5,id6]... etc\r\n     * ]\r\n     *\r\n     * @param routeArray\r\n     * @returns\r\n     */\n\n\n    generateExampleReport(routeArray) {\n      let report = \"\";\n      let quantity = 1;\n      routeArray.forEach((route, i) => {\n        // check if its a new paragraph...\n        if (route[0] !== \"newParagraph\") {\n          // generate sentence option 1\n          const str = this.generateSentenceOptions(route);\n          quantity = quantity * str.length;\n          report += str[0].sentence;\n        }\n      });\n      return {\n        report: report,\n        options: quantity\n      };\n    }\n    /**\r\n     * Takes something of the form:\r\n     * [\r\n     *  [id1, id2, id3/id4/id5/id6],\r\n     *  [newparagraph],\r\n     *  [id7,id8/id9,id10]... etc\r\n     * ]\r\n     *\r\n     * with the / to indicate options being the differentiator.\r\n     *\r\n     * RETURNS a single report with the number of possible reports...\r\n     *\r\n     * @param routeArray\r\n     */\n\n\n    generateCompoundReport(routeArray, select = 1) {\n      // this function takes a route with options such as id1/id2/id3 etc and translates it into a report.\n      let sentenceOptions = {\n        report: [\"\"],\n        options: 1\n      };\n      let optionCalculator = 1; // iterate over each sentence stem\n\n      routeArray.forEach(route => {\n        // first get all postenital combinations\n        let routeOptions = this.cartesianProduct(route.map(x => x.split('/'))); // get an array of random numbers relating to sentences in the database. If select is -1 all sentence selected...\n\n        let selections = [...Array(select).keys()].map(x => select === -1 ? x : Math.floor(Math.random() * (routeOptions.length - 1))); // remove any repeats\n\n        selections = [...new Set(selections)]; // iterate over each of the route options\n        // this can definately be slicker in terms of efficiency but for nowMEH\n\n        routeOptions.forEach((routePossibility, index) => {\n          let exampleReports = this.generateExampleReport([routePossibility]); // get the options calculation\n\n          optionCalculator *= exampleReports.options; // select the random value for the report\n\n          if (selections.includes(index)) {\n            sentenceOptions.report.push(exampleReports.report);\n          }\n        });\n      }); // return\n\n      return {\n        report: sentenceOptions.report.join('').trim(),\n        options: optionCalculator\n      };\n    } // function is more my style :)\n\n    /**\r\n     * Cartesian product function... may be useful for the sentence generation also...\r\n     * @param route\r\n     * @returns\r\n     */\n\n\n    cartesianProduct(route) {\n      // check if the length of the route is equal to 0, and if it is just return a blank array        \n      if (route.length === 0) {\n        return [];\n      } // create two new arrays, one with the first entries, and one with the rest of the entries.\n\n\n      const first = route[0]; // set first to the first entry in the route, which for the first iteration is ['id1','id2'] \n\n      const rest = route.slice(1); // remove this first entry from the rest of the array\n      // if the rest of the entries has no length then we do not want to carry on, so we return\n      // the first entry with each individual entry set as an array.\n      // in the case of the first iteration (assumeing it was a single array) this would return [['id1'],['id2']]\n\n      if (rest.length == 0) {\n        return first.map(x => [x]);\n      } // if this was not the last entry we first need to iterate forward towards it, so simply recurse on this\n      // function with the reamining entries, in this case [['id3','id4'], ['id5','id6']]]\n\n\n      const cartesianEnd = this.cartesianProduct(rest); // finally caretesianEnd has the return values of all the recursive data\n      // first is entered as ['id1','id2']\n      // id is started as id1\n      // the return values of all progressive data is then mapped as ['id1', ... then the rest of the subsequent id combinations]\n      // in successive iterations this looks differently, for example when caretesianProduct triggers the first time then \n      // the 'first' variable has id as 'id3' and rest as 'id4'\n\n      return first.flatMap(id => cartesianEnd.map(restOfIds => [id, ...restOfIds]));\n    }\n\n    singleOptionStemGenerator(route) {\n      let returnArray;\n      route.forEach(options => {\n        // split into the various options\n        let splitOption = options.split('/');\n        splitOption.forEach(str => {\n          if (route.length > 1) {\n            this.singleOptionStemGenerator(route.splice(0, 1));\n          } else {\n            return str;\n          }\n        });\n      });\n      return returnArray;\n    }\n    /**\r\n     * The function used to modify the array - called with a callback from a separate function\r\n     * DONE\r\n     * @param position position in the array (levels of subcat)\r\n     * @param subPosition position in the subcat\r\n     * @param key the {key: value} pair to target\r\n     * @param newValue new value for the key\r\n     * @param callback the function to do the modification.\r\n     */\n    // modifyData(position: number, subPosition: number, key: string, newValue: string | boolean | number, callback?: Function): void {\n\n\n    modifyData(position, callback, route) {\n      let depth = 0;\n      let complete = false;\n      let returnValue;\n      this.sentenceData.forEach(function iterate(value, i) {\n        if (value.id === route[depth] && !complete) {\n          if (position === depth && !complete) {\n            // need to ensure this can add to the array if it isnt there already...\n            returnValue = callback(value); // delet this row below when implemented fully.\n            // value.subcategories[subPosition][key] = newValue;\n\n            complete = true;\n          } else {\n            depth++;\n            Array.isArray(value.subcategories) && !complete && value.subcategories.forEach(iterate);\n          }\n        }\n      });\n      return returnValue;\n    }\n    /**\r\n     * Add a new sub level to a part of the array\r\n     * DONE\r\n     * @param position depth of the subarrays\r\n     */\n\n\n    addNewSubLevel(position, route) {\n      const callback = value => {\n        try {\n          value.subcategories.push({\n            name: `${value.subcategories.length + 1}`,\n            id: `${this.generateId()}`\n          });\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n     * Add a new test to a stem...\r\n     * DONE\r\n     * @param position depth into the array\r\n     * @param subPosition position on a subcategory\r\n     */\n\n\n    addNewTest(position, subPosition, route) {\n      const callback = value => {\n        try {\n          const testsAlreadyMade = value.subcategories[subPosition]['tests'] ? true : false;\n          const sentencesAlreadyMade = value.subcategories[subPosition]['sentence'] ? true : false;\n          const testIdent = document.getElementById('newTest').value; // const test: Test = this.testsService.testsList.find((temp: Test) => temp.name === testName);\n\n          const test = this.testsService.testsList.find(temp => temp.identifier === testIdent);\n\n          if (test !== undefined) {\n            // if the test was found add it...\n            const options = test.test.options ? test.test.options : null;\n            const newTest = {\n              name: test.name,\n              identifier: test.identifier,\n              values: {\n                name: test.test.name,\n                value: \"\",\n                options: options\n              }\n            }; // first add the test\n\n            if (testsAlreadyMade) {\n              value.subcategories[subPosition]['tests'].push(newTest);\n            } else {\n              value.subcategories[subPosition]['tests'] = [newTest];\n            }\n          }\n\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n    * Remove a test from something\r\n    * DONE\r\n    * @param position dpeth into the array\r\n    * @param subPosition position in the subcategory\r\n    * @param testNumber the index of the test\r\n    */\n\n\n    removeTest(position, subPosition, testNumber, route) {\n      const callback = value => {\n        try {\n          value.subcategories[subPosition].tests.splice(testNumber, 1);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n\n    modifyTestValue(position, index, testIndex, route, modifiedValue) {\n      const callback = value => {\n        try {\n          value.subcategories[index].tests[testIndex].values.value = modifiedValue;\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n\n    modifyTestName(position, index, testIndex, route, modifiedValue) {\n      const callback = value => {\n        try {\n          value.subcategories[index].tests[testIndex].name = modifiedValue;\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n     * Check if the test you want to add is already on the object\r\n     *\r\n     * UNKNWON IF NEEDED CHECK ON MAIN COMPUTER\r\n     *\r\n     * @param tests lists of the tests\r\n     * @param name name of the test you want to add\r\n     * @returns true or false if it exists or not...\r\n     */\n\n\n    checkIfTestAlreadyAdded(tests, name) {\n      return tests.includes(each => each.name === name);\n    }\n    /**\r\n     * Delete this sentence stem\r\n     * DONE\r\n     * @param position depth within the array\r\n     * @param index position within the subcategories\r\n     */\n\n\n    deleteRoute(position, index, route) {\n      const callback = value => {\n        // add to undo what is about to happen\n        const fn = data => {\n          value.subcategories.push(data);\n        }; // add to undo list\n\n\n        const returnValue = {\n          text: \"Deletion of \" + value.subcategories[index].name,\n          stem: value.subcategories[index],\n          fn: fn\n        }; // remove the item from the array\n\n        value.subcategories.splice(index, 1); // return the undo data...\n\n        return returnValue;\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n     * Modify the sentence data (the text)\r\n     * DONE\r\n     * @param position position within the array\r\n     * @param subPosition position within the sub array\r\n     * @param sentenceIndex position in the sentence index\r\n     * @param newComment the replacement comment\r\n     */\n\n\n    modifySentenceData(position, subPosition, sentenceIndex, newComment, route) {\n      const callback = value => {\n        try {\n          value.subcategories[subPosition]['sentence'][sentenceIndex] = newComment.target.innerText;\n          return true;\n        } catch (e) {\n          console.log(`Error: ${e.message}`);\n          return false;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n     * Add a new sentence to a sentence stem\r\n     * DONE\r\n     * @param position position within the array\r\n     * @param subPosition position within the subcategories\r\n     */\n\n\n    addNewSentence(position, subPosition, route) {\n      const callback = value => {\n        const sentencesAlreadyMade = value.subcategories[subPosition]['sentence'] ? true : false;\n\n        try {\n          if (sentencesAlreadyMade) {\n            value.subcategories[subPosition]['sentence'].push(\"\");\n          } else {\n            value.subcategories[subPosition]['sentence'] = [\"\"];\n          }\n\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n     * Delete a sentence from the database\r\n     * DONE\r\n     * @param position position within the array\r\n     * @param subPosition position within the subcategories\r\n     * @param sentenceIndex position within the sentence array\r\n     */\n\n\n    deleteSentence(position, subPosition, sentenceIndex, route) {\n      const callback = value => {\n        try {\n          value.subcategories[subPosition].sentence.splice(sentenceIndex, 1);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n     * Modify the name of the stem\r\n     * DONE\r\n     * @param position position within the array\r\n     * @param subPosition position within the subcategories\r\n     * @param newComment new name\r\n     */\n\n\n    modifyName(position, subPosition, newComment, route) {\n      const callback = value => {\n        try {\n          value.subcategories[subPosition]['name'] = newComment.target.innerText;\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n     * Modify the start point data (true -> false, false -> true)\r\n     * DONE\r\n     * @param position position within the array\r\n     * @param subPosition position within the subcategories\r\n     * @param currentState current state of the start data\r\n     */\n\n\n    modifyStartpointData(position, subPosition, currentState, route) {\n      const callback = value => {\n        try {\n          value.subcategories[subPosition]['starter'] = !currentState;\n          return true;\n        } catch (e) {\n          return false;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n     * Copy a sentence type from the database...\r\n     * DONE\r\n     * @param position The position of thecopied item\r\n     * @param subPosition The position within the subposition array\r\n     */\n\n\n    copyItem(position, subPosition, route) {\n      const callback = value => {\n        // slow copy but good enough for this use case...\n        try {\n          return JSON.parse(JSON.stringify(value.subcategories[subPosition]));\n        } catch (error) {\n          return undefined;\n        }\n      };\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n     * Paste the copied item into this position.\r\n     * @param position The point to place the pasted item.\r\n     */\n\n\n    pasteItem(position, copiedItem, route) {\n      const callback = value => {\n        // all the items need a new id.\n        // new generate id function (as this.generateId cant be passed into the recursive function)\n        const genNewId = () => {\n          return this.generateId();\n        };\n\n        copiedItem.id = genNewId(); // recursively iterate through the copied item to replace the ids on the new items (the only part which isnt copied...)\n\n        if (Array.isArray(copiedItem.subcategories)) {\n          copiedItem.subcategories.forEach(function iterate(stem, index) {\n            // generate a new id\n            stem.id = genNewId(); // iterate over the subcategories and add an id to each\n\n            if (Array.isArray(stem.subcategories)) {\n              stem.subcategories.forEach(iterate);\n            }\n          }, genNewId);\n        } // put the pasted item into the right place.\n\n\n        try {\n          value.subcategories.push(copiedItem);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }; // attempt to paste it...\n\n\n      return this.modifyData(position, callback, route);\n    }\n    /**\r\n     * Reorder the item to the left - essentially making it the same level as its master.\r\n     * MOVED OVER...\r\n     * @param position the depth of the item within the database\r\n     * @param subPosition the position in the subcategory of the parent\r\n     */\n\n\n    reOrderItemLeft(position, subPosition, route) {\n      const callback = value => {\n        const subCallback = subValue => {\n          // duplicate the item one position down\n          subValue.subcategories.push(value.subcategories[subPosition]);\n        };\n\n        this.modifyData(position - 1, subCallback, route); // and remove the initial value\n\n        value.subcategories.splice(subPosition, 1);\n      };\n\n      try {\n        this.modifyData(position, callback, route);\n        return true;\n      } catch (error) {\n        console.log(error.message);\n        return false;\n      }\n    }\n    /**\r\n     * Generate a new random ID...\r\n     * DONE\r\n     * @returns\r\n     */\n\n\n    generateId() {\n      let newId = \"\"; // get the characterset, length of character set and intended length of random ID.\n\n      const characterset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n      const numberOfCharacters = characterset.length;\n      const length = 5; // 5 seems good, 62^5\n      // generate a random number\n\n      for (let i = 0; i < length; i++) {\n        newId += characterset.charAt(Math.floor(Math.random() * numberOfCharacters));\n      }\n\n      return newId;\n    }\n\n    testValueValidation(value, test) {\n      return test.test.validityFunction(value);\n    }\n    /**\r\n     * A helper function to strip off any ${g|v|[]}$ and leave the name intact\r\n     * @param report\r\n     */\n\n\n    stripVariables(report) {\n      // first if there is a (notation) then escape it so it works properly...\n      // then get to replacing text!W\n      let strReplace = new RegExp('\\\\$\\\\{([vgn]{1,2}\\\\|+([^\\\\}\\\\[]*)+(\\\\[.*?])?)\\\\}\\\\$', 'gi');\n      let regExData;\n\n      while ((regExData = strReplace.exec(report)) !== null) {\n        let replaceStr = regExData[3] ? regExData[3].split(',').join(' or ') : regExData[2];\n        report = report.replace(regExData[0], '<span class=\"create-template__highlight\">' + replaceStr + '</span>');\n        strReplace.lastIndex = 0;\n      }\n\n      return report;\n    }\n\n  }\n\n  SentencesService.ɵfac = function SentencesService_Factory(t) {\n    return new (t || SentencesService)(i0.ɵɵinject(i1.DatabaseService), i0.ɵɵinject(i2.TestsService), i0.ɵɵinject(i3.GroupsService));\n  };\n\n  SentencesService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: SentencesService,\n    factory: SentencesService.ɵfac,\n    providedIn: 'root'\n  });\n  return SentencesService;\n})();","map":null,"metadata":{},"sourceType":"module"}