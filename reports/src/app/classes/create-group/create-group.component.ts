import { Component, OnInit } from '@angular/core';
import { DocumentReference } from '@angular/fire/firestore';
import { CustomService } from 'src/app/services/custom.service';
import { GroupsService, Student, Group } from 'src/app/services/groups.service';
import { AuthenticationService } from 'src/app/services/authentication.service';
import { User } from 'src/app/utilities/authentication/user.model';

@Component({
  selector: 'app-create-group',
  templateUrl: './create-group.component.html',
  styleUrls: ['./create-group.component.scss']
})
export class CreateGroupComponent implements OnInit {

    headerRow: boolean = true;
    verticalData: boolean = true;
    keys: string[] = [];
    userData: Student[] = [];
    user: User;
    groupname: string;
    groupDescription: string = "";
    userDataGenerated: boolean = false;
    dataSubmitting: boolean = false;
    dataUpdating: boolean = false; // data is currently being updated...
    dataUpdated: boolean = false; // data has been saved since updating (databe is up to dtae)
    dataChanged: boolean = false;
    groupId: string; // if the class has been created this will be populated with the database id.

    numberOfStudents: number;

    helpFlag: boolean;

    constructor(
        private groupService: GroupsService,
        private auth: AuthenticationService,
        public customService: CustomService
    ) {
        auth.user.subscribe((user: User) => {
            this.user = user;
        })

        customService.greaterTooltipsFlag.subscribe((newFlag: boolean) => {
            this.helpFlag = newFlag;
        })
    }

    ngOnInit(): void {
    }

    createGroup(): void {
        this.dataSubmitting = true;
        let group: Group = { name: this.groupname, description: this.groupDescription, keys: [], managers: [], students: []};
        let managers: string[] = [this.user.id];
        let students: Student[] = [];

        this.userData.forEach((student: Student) => {
            students.push(student);
        })

        group.managers = managers;
        group.students = students;
        group.keys = this.keys;

        this.groupService.addGroup(group).subscribe({
            next: (returnData: DocumentReference) => {
                console.log(`Success: ID ${returnData.id}`);
                this.groupId = returnData.id;
        },  error: (error) => {
                console.log(`Error: ${error.message}`);
        },  complete: () => {
                this.dataSubmitting = false;
        }})
    }

    updateGroup(): void {
        this.dataSubmitting = true;
        this.dataUpdating = true;
        let group: Group = { name: this.groupname, keys: [], managers: [], students: []};
        let managers: string[] = [this.user.id];
        let students: Student[] = [];

        this.userData.forEach((student: Student) => {
            students.push(student);
        })

        group.managers = managers;
        group.students = students;
        group.keys = this.keys;

        this.groupService.updateGroup(group, this.groupId).subscribe({
            next: () => {
                console.log(`Successfully modified data`);
                this.dataUpdated = true;
        },  error: (error) => {
                console.log(`Error: ${error.message}`);
        },  complete: () => {
                this.dataSubmitting = false;
                this.dataUpdating = false;
                this.dataChanged = false;
        }})
    }

    userInfo: string;
    separation: string = ''; //default to tab separated... \\t
    separationRegEx: RegExp = new RegExp(this.separation);

    setDataSeparation(sepIndicator: string): void {
        this.separation = sepIndicator;
        this.separationRegEx = new RegExp(''+sepIndicator);
    }

    dataStructureMethods: { id: number, text: string, subMethods: { id: number, show: { studentNumbers: boolean, header: boolean, vertical: boolean, createButton: boolean }, text: string, image: string, function?: any, input?: { id: string, type: string, text: string }[]}[]}[] = [
      {
        id: 0,
        text: 'Attempt an automatic data sort (Experimental!)',
        subMethods: [{ id: 0, show: { studentNumbers: true, header: true, vertical: true, createButton: true }, text: 'ReportsZone will try to work it out for you!', image: '', function: () => { if(this.verticalData) { this.verticalColumnsDataGeneration(); this.smartSplit(); }  else { this.autoGenerateData() } } }]
      },{
        id: 1,
        text: 'Data from Powerschool',
        subMethods: [{
          id: 0, show: { studentNumbers: false, header: true, vertical: false, createButton: true }, text: 'Copy and paste from Powerteacher Pro',
          image: '',
          function: () => { this.verticalColumnsDataGeneration(); this.smartSplit(); this.trimAllData(); }
        }, {
          id: 1, show: { studentNumbers: false, header: true, vertical: false, createButton: true }, text: 'Powerteacher Pro Export',
          image: '',
          function: () => { this.generateUserDataRowByRow('\n', '[,\\t]'); }
        }]
      }, {
        id: 2,
        text: 'Data from Excel or Google Sheets',
        subMethods: [{
          id: 0, show: { studentNumbers: false, header: true, vertical: false, createButton: true }, text: 'Copy and pasted data from a spreadsheet',
          image: '',
          function: () => { this.generateUserDataRowByRow('\n', '\\t'); }
        }]
      }, {
        id: 3,
        text: 'Manual Data Entry',
        subMethods: [{ id: 0, show: { studentNumbers: false, header: false, vertical: false, createButton: false }, text: 'Just do it yourself!', image: '', function: () => { } }]
      }, {
        id: 4,
        text: 'Data from a known data type (CSV, TSV etc)',
        subMethods: [{
          id: 0, show: { studentNumbers: false, header: true, vertical: false, createButton: true },text: 'CSV Data Type (Comma,separated,data)',
          image: '',
          function: () => { this.generateUserDataRowByRow('\n', ','); }
        },{
          id: 1, show: { studentNumbers: false, header: true, vertical: false, createButton: true },text: 'TSV Data Type (Tab  separated data)',
          image: '',
          function: () => { this.generateUserDataRowByRow('\n', '\\t'); }
        },{
          id: 2, show: { studentNumbers: false, header: true, vertical: false, createButton: true }, text: 'Other Separated Data Type',
          image: '',
          input: [{ id: 'characterSeparator', type: 'text' , text: 'What character separates your data?' }],
          function: (character: string) => { this.generateUserDataRowByRow('\n', character); }
        }]
      }
    ];

    topDataId: number = 0;
    subDataId: number = 0;

    setTopDataId(topId: number): void { this.topDataId = topId; this.subDataId = 0; }
    setSubDataId(subId: number): void { this.subDataId = subId; console.log(this.topDataId, this.subDataId); }

    setDataStructure(): void {
      // if there is more data input required then set that now...
      const method: { id: number, text: string, image: string, function?: any, input?: { id: string, type: string, text: string }[]} = this.dataStructureMethods[this.topDataId].subMethods[this.subDataId];
      const data: string[] = [];

      console.log(method);

      // retrive all the user input data...
      for(let i = 0 ; i < method.input?.length ; i++) {
        let element: HTMLInputElement = document.getElementById(method.input[i].id) as HTMLInputElement;
        data.push(element.value);
      }

      // run the functions
      data.length > 0 ? method.function(...data) : method.function();

    }

    /**
     * Smart split iterates over the data to see if there are any likely candidates for splitting data...
     */
    smartSplit(): void {
      // now iterate over the data to match any common splitters in copy andf pasted text which normally wouldnt appear
      // in a value or number in data, for example a comma.
      for(let i = 0 ; i < this.keys.length ; i++) {
        let key: string = this.keys[i];
        let testCharacters: string[] = [',', '\t', ' '];

        for(let c = 0; c < testCharacters.length ; c++) {
          let char: string = testCharacters[c];

          for(let o = 0 ; o < this.userData.length ; o++) {
            // for each user test the key against the characters. If a split might work for one of them, try it!
            if(this.userData[o].data[key].split(char).length > 1) {
              this.splitColumn(i, char);
              i = -1;
              c = testCharacters.length + 1;
              break;
            }
          }
        }
      }
      // this could generate a bunch of empty columns, so just in case remove empty columns...
      this.deleteEmptyColumns();
    }


    deleteEmptyColumns(): void {
      let colsToDelete: string[] = [];

      for(let i = 0 ; i < this.keys.length ; i++) {
        let dataExists: boolean = false;
        // iterate over all users to see if anybody has a piece of data for this...
        for(let o = 0 ; o < this.userData.length ; o++) {
          if(this.userData[o].data[this.keys[i]] !== "") {
            dataExists = true;
            break;
          }
        }
        // set it up to delete later...
        if(!dataExists) { colsToDelete.push(this.keys[i]); }
      }

      for(let i = 0 ; i < colsToDelete.length ; i++) { this.deleteColumn(colsToDelete[i]); }
    }

    /**
     * A function which trims witespace off the end of all data.
     * ONLY should be used if all data has been split up as this might
     * change the format of copy and pasted data.
     */
    trimAllData(): void {
      this.userData.forEach((user: Student) => {
        for(let i = 0 ; i < this.keys.length ; i++) {
          user.data[this.keys[i]] = user.data[this.keys[i]].trim();
        }
      })
    }

    /**
     * Has an attempt at auto generating data from whatever is in the box.
     * Requires consistency
     */
    autoGenerateData(): void {
      const separationTokens: string[] = [',', '\t', '|', ' ', '\n', '/', '\\', '-', ':', ';'];
      let potentialOptions: { token: string, subToken: string, count: number }[] = [];

      // set a nujmber of expected students if the number of students i defined.
      const expectedStudents: number = +this.numberOfStudents ? +this.numberOfStudents + (this.headerRow ? 1 : 0) : NaN;

      for(let i = 0 ; i < separationTokens.length; i++) {
        const token: string = separationTokens[i];
        // const userData: string[] = this.userInfo.trim().split(token);
        const userData: string[] = this.userInfo.split(token);
        const count: number = userData.length;

        // if the number of hits from this token are the same (or 1 less if the last record has no token to end it)
        // then we may have how the students are divided up...
        // also if expected students isnt set, because then we have to guess!
        if(count === expectedStudents || count === (expectedStudents - 1) || isNaN(expectedStudents)) {
          // now see how the userdata might be split up
          console.log(`It seems to be splitting lines with ${token}`);

          // try each token which is not the initial token to see how the string might break up.
          // the idea here is that if say all users are aparated by a comma, each row will have the same number
          // of commas...

          for(let s = 0 ; s < separationTokens.filter(tmp => tmp !== token).length ; s++) {
            let consistent: boolean = true;
            let subToken: string = separationTokens[s];
            let lastCount: number = 0;

            // now iterate over each piece of data to see if this token might be the deliniator...
            for(let o = 1 ; o < userData.length; o++) {
              let pastCount: number = userData[o-1].trim().split(subToken).length;
              let presentCount: number = userData[o].trim().split(subToken).length;

              // see if there are a consistent number of these values in each row.
              consistent = pastCount === presentCount && pastCount > 1 && presentCount > 1;

              // if not, then this is unlikely to be the deliniator and so move on...
              if(!consistent) { break; }

              lastCount = pastCount;
            }

            // if this is consistent add it to the list off possibilities...
            if(consistent) potentialOptions.push({ token: token, subToken: subToken, count: lastCount });
          }
        }
      }

      // sort the potential options os the one with the most postential is presented first
      // filter all with no chance.
      potentialOptions = potentialOptions.filter(t => t.count > 0);
      // then sort by \n first and then by the count number.
      potentialOptions = potentialOptions.sort((a, b) => {
        let score: number = b.count - a.count;
        let alphaScore: boolean = a.token === '\n'; // new lines trump almost all as they signify multiple lines of data which is LIKELY
        let betaScore: boolean = b.token === '\n';
        let bothAlpha: boolean = b.token === a.token;

        if(alphaScore && !bothAlpha) return -1; //more a up over b if they arent both alpha
        if(betaScore && !bothAlpha) return 1;
        return score;
      });

      this.potentialOptions = potentialOptions;
      if(this.potentialOptions.length > 1) this.autoGenerationAttempted = true;
      this.displayNextAutoPotential();
    }

    autoGenerationAttempted: boolean = false;
    potentialOptions: { token: string, subToken: string, count: number }[] = [];

    /**
     * Switches to the next set of data potential.
     */
    displayNextAutoPotential(): void {
        if(this.potentialOptions.length > 0) {
            console.log(`Displaying ${this.potentialOptions[0].token} and ${this.potentialOptions[0].subToken}`);
            this.generateUserDataRowByRow(this.potentialOptions[0].token, this.potentialOptions[0].subToken);
            this.potentialOptions.shift();
        }
    }

    splitColumnToggle: number = -1;

    /**
     * Toggles the split column view
     * @param keyId
     */
    toggleSplitColumn(keyId: number): void { this.splitColumnToggle = keyId === this.splitColumnToggle ? -1 : keyId; }

    /**
     * Splits a column by a delimiter
     * @param keyIndex
     * @param delimiter
     */
    splitColumn(keyIndex: number, delimiter: string): void {
      let keyToSplit: string = this.keys[keyIndex];

      let headerNames: string[] = []
      // if there is a header row try and split that...
      // unchecked yet...
      if(this.headerRow) {
        let header: string[] = this.keys[keyIndex].split(delimiter);

        while(header.length > 0) {
            let newHeader: string = header.shift();
            headerNames.push(newHeader);
        }
      } else {
        // no header so make up names...
        let maxHeaders: number = 0;
        // find out the max nujmber of headers
        for(let l = 0 ; l < this.userData.length ; l++) {
            let length: number = this.userData[l].data[keyToSplit].split(delimiter).length;
            if(length > maxHeaders) maxHeaders = length;
        }
        // create all headers needed...
        for(let i = 0 ; i < maxHeaders; i++) {
            headerNames.push(`${this.keys[keyIndex]} (split ${i + 1})`);
        }
      }

      // add the new keys...
      this.keys.splice(keyIndex, 0, ...headerNames);

      for(let i = 0 ; i < this.userData.length ; i++) {
        let split: string[] = this.userData[i].data[keyToSplit].split(delimiter);
        let keyId: number = 0;
        // for each user check each header name...
        for(let o = 0 ; o < headerNames.length ; o++) {
            let firstEntry: string = split.length > 0 ? split.shift() : '';
            this.userData[i].data[headerNames[keyId]] = firstEntry;
            // this.userData[i].data[headerNames[keyId]] = firstEntry.trim();
            keyId++;
        }
      }

      this.deleteColumn(keyToSplit);
      this.splitColumnToggle = -1;
    }

    /**
     * If the number of students are known and that the data is vertical this should be easy...
     */
    verticalColumnsDataGeneration(): void {
      this.userDataGenerated = true;
      this.groupId = undefined;
      this.modifyData = false;
      const dataRows: string[] = this.userInfo.split('\n');
      const rowCount: number = this.userInfo.split('\n').length;
      const studentPlusHeaderCount: number = this.headerRow ? this.numberOfStudents + 1 : this.numberOfStudents;
      this.keys = [];
      this.userData = [];

      if(this.numberOfStudents) {
        // if we know the number of students this should be fine...
        const rowsPerUser: number = rowCount / studentPlusHeaderCount;

        // add the keys...
        for(let i = 0 ; i < rowsPerUser ; i++) {
          // if a heade row exists use those values, if not make up random ones.
          if(this.headerRow) {
            let findIndex: number = this.keys.findIndex((t: string) => t === dataRows[i]);
            if(findIndex === -1) {
              // key doesnt exist so just make it so.
              this.keys.push(dataRows[i]);
            } else {
              // the key already exists so append with a number...
              let keyCount: number = this.keys.filter((t: string) => t === dataRows[i]).length;
              this.keys.push(dataRows[i] + keyCount);
            }
          } else {
            // there is no header so generate random keys...
            this.keys.push('Column ' + (i + 1));
          }
        }

        for(let i = (this.headerRow ? rowsPerUser - 1 : 0) ; i < dataRows.length ; i+=rowsPerUser) {

          let user = { id: this.groupService.generateRandomId(), data: {} };
          // and iterate over the number of rows per user...

          for(let o = 0 ; o < rowsPerUser ; o++) {
              const keyName: string = this.keys[o];
              const dataPoint: string = dataRows[i + o] ? dataRows[i + o] : "";
              user.data = { ...user.data, [keyName.trim()] : dataPoint };
              // user.data = { ...user.data, [keyName.trim()] : dataPoint.trim() };
          }

          this.userData.push(user);
        }

      } else {
        // if we dont, we should do some factorisation to see what might work, for example
        // if there are 32 lines it could be 2 lines per student, 4 lines, 8 lines or 16 lines
        // generate some options.
      }
    }

    generateUserDataRowByRow(rows: string = '\n', colDeliniator?: string) {
        this.userDataGenerated = true;
        this.groupId = undefined;
        this.modifyData = false;
        let data: string[];

        // if the deliniator flag is set then use that to work it out...
        if(colDeliniator) this.setDataSeparation(colDeliniator);

        data = this.userInfo.split(rows);

        // get data and split into individual elements
        let keys: string[] = [];

        // if there is a header row build a list of the keys to use for this dataset
        if(this.headerRow) {
            // keys = data[0].split(",").map((a: string) => a.trim());
            keys = data[0].split(this.separationRegEx).map((a: string) => a.trim());

            // check for duplicate key names and rename them...
            keys.forEach((key: string, index: number) => {
                let keyArray: string[] = [...keys];
                keyArray.splice(index, 1); // remove the tested value...
                let findIndex: number = keyArray.findIndex((t: string) => t === key);
                // test if it is a duplicate elsewhere...
                if(findIndex !== -1) { keys[index] = key + index; }
            })
            data.splice(0, 1);
        } else {
            // create a set of keys which is just numbers...
            // data[0].split(",").forEach(() => {
            data[0].split(this.separationRegEx).forEach(() => {
                keys.push(`Column ${keys.length + 1}`);
            })
        }

        // set keys globally to be accessed in the dom
        this.keys = keys;

        // iterate over the data and build a new array
        let newData = [];

        data.forEach((row: string) => {
            // let newUserData = row.split(",");
            let newUserData = row.split(this.separationRegEx);
            // [message, message]
            let user = { id: this.groupService.generateRandomId(), data: {} };

            // user a for loop to ensure even if a value is not defined it exists as a blank in the array
            for(let t = 0 ; t < keys.length ; t++) {
                const keyName: string = keys[t];
                const dataPoint: string = newUserData[t] ? newUserData[t] : "";
                user.data = { ...user.data, [keyName.trim()] : dataPoint };
                // user.data = { ...user.data, [keyName.trim()] : dataPoint.trim() };
            }
            // push to the newdata array
            newData.push(user);
        })

        this.userData = newData;
    }

    /**
     * Returns the position of a user within their group.
     * @param userId
     */
    getIndexPositionById(userId: string): number {
        const index: number = this.userData.findIndex((temp: Student) => temp.id === userId);
        return index;
    }

    /**
     * Chnage a value for one of the users.
     * @param index
     * @param key
     * @param input
     */
    userValueChange(userId: string, key: string, input: string) {
        const newValue: string[] = input.split("\n");
        const userIndex: number = this.getIndexPositionById(userId);

        if(userIndex !== -1) {
          console.log(`Changiong ${this.userData[userIndex].data[key]} to ${input} on key ${key}`);
            this.userData[userIndex].data[key] = newValue[0];
            console.log(`Reporting ${this.userData[userIndex].data[key]}`);
            this.dataUpdated = false;
            this.dataChanged = true;
        }
    }

    /**
     * Remove a user
     * @param index
     */
    removeUser(userId: string): void {
        const userIndex: number = this.getIndexPositionById(userId);

        if(userIndex !== -1) {
            this.userData.splice(userIndex, 1);
            this.dataUpdated = false;
            this.dataChanged = true;
        } else {
            console.log("Error, user not found...");
        }
    }

    /**
     * Chnage one of the column values - the titles.
     * This needs to change each of the values in each of the user entries too.
     * @param index
     * @param input
     */
    columnValueChange(index: number, input: string) {
        const newKeyArray: string[] = [...this.keys];

        newKeyArray[index] = input;

        let newData: Student[] = [];

        // iterate over the data and build a new array
        this.userData.forEach((row: Student) => {
            let newDataUser: Student = { id: row.id, data: {} };
            // go through the array line by line changing the key values...
            this.keys.forEach((key: string, i: number) => {
                const newKey = { [(''+newKeyArray[`${i}`]).trim()] : row.data[`${key}`] }
                newDataUser = { id: newDataUser.id, data: {...newDataUser.data, ...newKey}};
            })

            // add ot the new array
            newData.push(newDataUser);
        })

        this.keys = newKeyArray;
        this.userData = newData;
        this.dataUpdated = false;
        this.dataChanged = true;
    }

    /**
     * Adds a new column to the data - will name it col length...
     */
    addColumn(): void {
        // add to the keys...
        const colName = `Column ${this.keys.length + 1}`;
        this.keys.push(colName);

        // new data
        let newData = [...this.userData];

        // iterate over and add to each of the userdata...
        newData.forEach((row: Student) => {
            row.data[colName] = "";
        });

        this.userData = newData;
        this.dataUpdated = false;
        this.dataChanged = true;
    }

    /**
     * removes a column
     * @param index
     */
    deleteColumn(index: string): void {
      // find the key index...
      let keyIndex: number = this.keys.findIndex((key: string) => key === index);

      // if found do the stuff...
      if(keyIndex !== -1) {
          // and remove from each of the user data array
          this.userData.forEach((row: Student) => {
              delete row.data[index];
          });

          // and remove from the keys index...
          this.keys.splice(keyIndex, 1);
          this.dataUpdated = false;
          this.dataChanged = true;
        }
    }

    /**
     * keyvalue pipe orders alphabetically automatically. This stop that.
     * deprecated
     * @returns number 0
     */
    // returnZero(): number {
    //     return 0;
    // }

    // deprecated
    // sortDataForDisplay(data: {}): {} {
    //     let returnValue: {} = {};

    //       console.log(`Soring by ${this.keys}`);

    //     // sort the data into the same order as the keys.,..
    //     this.keys.forEach((key: string) => {
    //         const newKey: {} = { [''+key] : data[key] };
    //         returnValue = {...returnValue, ...newKey};
    //     })

    //     console.log(returnValue);

    //     return returnValue;
    // }

    modifyData: boolean = false;

    modifyGroupData(): void {
        this.modifyData = !this.modifyData;
    }

    createNewGroup(): void {
        this.userData = undefined;
        this.userInfo = undefined;
        this.groupDescription = undefined;
        this.groupname = undefined;
        this.keys = undefined;
        this.modifyData = false;
        this.userDataGenerated = false;
        this.dataSubmitting = false;
        this.dataUpdating = false; // data is currently being updated...
        this.dataUpdated = false; // data has been saved since updating (databe is up to dtae)
        this.dataChanged = false;
        this.groupId;
    }

    /**
     * Adds a new user to the group...
     */
    addNewUser(): void {
      const newUser: Student = {
        id: this.groupService.generateRandomId(),
        data: Object.fromEntries(this.keys.map(key => [key, '']))
      };
      this.userData.push(newUser);
    }

}

let testData =
`Forename,Surname,Nickname,Gender
Minerva,Dursley,Minerva,M
Cho,Santiago,Cho,M
Molly,Potter,Molly,M
George,Dursley,George,F
Ron,McGonagall,Ron,M
Hermione,Dursley,Hermione,F
Albus,,Albus,M
George,McGonagall,George,F
Ron,Santiago,Ron,M
Ginny,Weasley,,M
Charlie,Dursley,Charlie,M
Cho,Dumbledore,Cho,F
Hermione,Dursley,Hermione,M
Charlie,Boyle,Charlie,F`;
